
#include "typedefine.h"
#include "serial.h"

// -------------------------------------------------------
// ----------------------------- Functions ( subroutines )
//
//  serial (SCId) utilities 
//
void Ser5PortInit( uint8_t ch ){
  switch( ch ){
  case SER_HOST:
    // PE1, PE2 -> UART Port setting (Rx/Tx) 
    PORTC.PCR.BIT.B2   = PCR_PULLUP;         // PCR_OPEN / PCR_PULLUP
    PORTC.PODR.BIT.B3  = 0;
    PORTC.PMR.BIT.B2   = PMR_GPIO;         // PMR_GPIO / PMR_FUNC
    PORTC.PMR.BIT.B3   = PMR_GPIO;         // PMR_GPIO / PMR_FUNC
    PORTC.PDR.BIT.B2   = PDR_IN;           // PDR_IN / PDR_OUT
    PORTC.PDR.BIT.B3   = PDR_OUT;          // PDR_IN / PDR_OUT
    MPC.PC2PFS.BIT.PSEL  = PC2PFS_RXD5;
    MPC.PC3PFS.BIT.PSEL  = PC3PFS_TXD5;
    PORTC.PMR.BIT.B2     = PMR_FUNC;       // PMR_GPIO / PMR_FUNC
    PORTC.PMR.BIT.B3     = PMR_FUNC;       // PMR_GPIO / PMR_FUNC
    break;
  default:
    break;
  }
  return();
}

void Ser12PortInit( void ){
  // PE1, PE2 -> UART Port setting (Rx/Tx)
  PORTE.PODR.BIT.B1  = 0;
  PORTE.PCR.BIT.B2   = PCR_PULLUP;         // PCR_OPEN / PCR_PULLUP
  PORTE.PMR.BIT.B1   = PMR_GPIO;         // PMR_GPIO / PMR_FUNC
  PORTE.PMR.BIT.B2   = PMR_GPIO;         // PMR_GPIO / PMR_FUNC
  PORTE.PDR.BIT.B1   = PDR_OUT;          // PDR_IN / PDR_OUT
  PORTE.PDR.BIT.B2   = PDR_IN;           // PDR_IN / PDR_OUT
  MPC.PE1PFS.BIT.PSEL  = PE1PFS_TXD12;
  MPC.PE2PFS.BIT.PSEL  = PE2PFS_RXD12;
  PORTE.PMR.BIT.B1     = PMR_FUNC;       // PMR_GPIO / PMR_FUNC
  PORTE.PMR.BIT.B2     = PMR_FUNC;       // PMR_GPIO / PMR_FUNC
  return();
}

void SerStop( st_Serial *ser, uint8_t ch ){
  ser->addr_base = 0x8A000 + 0x20*ch;
  *(ser->addr_base).SCR.TEIE = SCId_TEIE_DE;    // A TEI interrupt request is disabled
  *(ser->addr_base).SCR.RE   = SCId_RE_DE;      // Serial reception is disabled
  *(ser->addr_base).SCR.RIE  = SCId_RIE_DE;     // RXI and ERI interrupt requests are disabled
  *(ser->addr_base).SCR.TE   = SCId_TE_DE;      // Serial transmission is disabled
  *(ser->addr_base).SCR.TIE  = SCId_TIE_DE;     // A TXI interrupt request is disabled
}

void Ser12Stop( void ){
  SCI12.SCR.TEIE = SCId_TEIE_DE;    // A TEI interrupt request is disabled
  SCI12.SCR.RE   = SCId_RE_DE;      // Serial reception is disabled
  SCI12.SCR.RIE  = SCId_RIE_DE;     // RXI and ERI interrupt requests are disabled
  SCI12.SCR.TE   = SCId_TE_DE;      // Serial transmission is disabled
  SCI12.SCR.TIE  = SCId_TIE_DE;     // A TXI interrupt request is disabled
}

void Ser12Start( void ){
  // start to communicate with UART
  SCI12.SCR.TEIE = SCId_TEIE_DE;    // A TEI interrupt request is disabled
  SCI12.SCR.RE   = SCId_RE_EN;      // Serial reception is enabled
  SCI12.SCR.RIE  = SCId_RIE_EN;     // RXI and ERI interrupt requests are enabled
  SCI12.SCR.TE   = SCId_TE_EN;      // Serial transmission is enabled
  SCI12.SCR.TIE  = SCId_TIE_EN;     // A TXI interrupt request is enabled
}

uint8_t SerGenBRR( st_Serial *ser,
		   uint32 brate, uint8_t xtal_mhz ){
  uint8_t A = 1;
  uint8_t pclk = 1;
  uint8_t n_calc = 3;
  // pclk
  switch( SYSTEM.SCKCR.BIT.FCK ){
  case XCK_DIV_4:
    // XTAL: xtal_mhz(12MHz) 16x/4 -> 48MHz ){
    pclk = xtal_mhz * 16 / 4;
    break;
  default:
    pclk = 1;
    break;
  }
  // check A (64/32)
  A = ( *(ser->addr_base).SEMR.ABCS ? 32 : 64 );
  // calc 2^(2n-1)
  switch( *(ser->addr_base).SMR.CKS ){
  case SCI_CKS_PCLK:
    n_calc = 1 / 2;
    break;
  case SCI_CKS_PCLK_4:
    n_calc = 2;
    break;
  case SCI_CKS_PCLK_16:
    n_calc = 8;
    break;
  case SCI_CKS_PCLK_64:
    n_calc = 32;
    break;
  default:
    n_calc = 32;
    break;
  }
  // calc
  return( pclk * 1000000 / ( A * n_calc * brate ) );
}

uint8_t Ser12FuncInit( st_Serial *ser){
  // PE1, PE2 -> UART IN/OUT
  SCI12.SCR.CKE    = SCId_CKE_OCHPIO;  // On-chip baud rate generator (SCK as I/O)
  SCI12.SIMR1.IICM = SCId_IICM_SCIF;   // Serial interface mode
  SCI12.SPMR.CKPOL = SCId_CKPOL_NORM;  // Clock polarity is not inverted.
  SCI12.SPMR.CKPH  = SCId_CKPH_NORM;   // Clock is not delayed.
  SCI12.SCMR.SMIF  = SCId_SMIF_SCIF;   // Serial communications interface mode
  SCI12.SCMR.SINV  = SCId_SINV_NORM;   // TDR contents are transmitted as they are.
  SCI12.SCMR.SDIR  = SCId_SDIR_LSB;    // Transfer with LSB-first
  /* SCI12.SEMR.ACS0  = SCId_ACS0_EXCLK;  // External clock input */
  /* SCI12.SEMR.ABCS  = SCId_ABCS_16CLK;  // Selects 16 base clock cycles for 1-bit period */
  SCI12.SMR.CKS    = SCId_CKS_PCLK;   // PCLK / 1
  SCI12.SMR.CM     = SCId_CM_ASYNC;   // Asynchronous mode
  SCI12.SMR.CHR    = SCId_CHR_8;      // Selects 8 bits as the data length
  SCI12.SMR.STOP   = SCId_STOP_1;     // 1 stop bit
  SCI12.SMR.PE     = SCId_PE_DE;      // Parity bit addition is not performed
  /* SCI12.SMR.PM   = SCId_PM_ODD      // Select odd parity */
  SCI12.SMR.MP     = SCId_MP_DE;      // disabled
  /* SCI12.SCR.MPIE = SCId_MPIE_NORM;  // Normal reception */
  /* SCI12.SSR.MPB = SCId_MPB_ID;    // ID transmission cycles */
  /* SCI12.SSR.MPBT = SCId_MPBT_ID;    // ID transmission cycles */

  // BAUDRATE = 9600 bps
  // PCLK => 12MHz * 4
  // CKS => PCLK / 1, n=0
  // calc: N = 48 * 10^6 / ( 64 * 2^(2n-1) * 9600 ) - 1
  //         = 3*2*2 * 10^6 / ( 2^5 * 9600 )        - 1
  //         = 3 * 10^4 / ( 2^3 * 96 )              - 1
  //         = 10^4 / ( 2^3 * 2^5 )                 - 1
  //         = 10000 / 256                          - 1
  //         = 39.06 - 1
  SCI12.BRR = 38;
  return();
}

void SerInit( st_Serial *ser, enum enum_SER_CHID ch ){
  // UART port initialization
  SerPortInit( ch );
  SerStop();
  SerFuncInit();
  // start to communicate with UART
  SerStart( ch );
}

void Ser12Init( void ){
  // UART port initialization
  Ser12PortInit();
  Ser12Stop();
  Ser12FuncInit();
  // start to communicate with UART
  Ser12Start();
}

uint8_t SerGetStat( st_Serial *ser){
  if( SCI12.SSR.TEND )
    ser->stat[SER_BUSY] = SCId_TEND_DONE;
  else
    ser->stat[SER_BUSY] = SCId_TEND_BUSY;
  if( SCI12.SSR.PER )
    ser->stat_err[SER_ERR_P] = SCId_PER_ERR;
  else
    ser->stat_err[SER_ERR_P] = SCId_PER_OK;
  if( SCI12.SSR.FER )
    ser->stat_err[SER_ERR_F] = SCId_FER_ERR;
  else
    ser->stat_err[SER_ERR_F] = SCId_FER_OK;
  if( SCI12.SSR.ORER )
    ser->stat_err[SER_ERR_OR] = SCId_FER_ERR;
  else
    ser->stat_err[SER_ERR_OR] = SCId_FER_OK;
  
/* enum enum_SCId_SSR_TEND { */
/*   // Transmit End Flag */
/*   SCId_TEND_BUSY, // A character is being transmitted. */
/*   SCId_TEND_DONE   // Character transfer has been completed. */
/* }; */

/* enum enum_SCId_SSR_PER { */
/*   // Parity Error Flag */
/*   SCId_PER_OK,   // No parity error occurred */
/*   SCId_PER_ERR   // A parity error has occurred */
/* }; */

/* enum enum_SCId_SSR_FER { */
/*   // Framing Error Flag */
/*   SCId_FER_OK,   // No framing error occurred */
/*   SCId_FER_ERR   // A framing error has occurred */
/* }; */

/* enum enum_SCId_SSR_ORER { */
/*   // Overrun Error Flag */
/*   SCId_ORER_OK,   // No overrun error occurred */
/*   SCId_ORER_ERR   // A overrun error has occurred */
/* }; */ 
  return( 0 );
}

/* end of serial.c */
